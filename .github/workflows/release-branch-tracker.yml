name: Comment on Fixed Issues (Filtered by Release Date and Comment User)

on:
  create:
    # Trigger when a branch matching release/* is created.
    branches:
      - 'release/*'

jobs:
  comment-on-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Process issues for new release
        uses: actions/github-script@v6
        with:
          script: |
            const { owner, repo } = context.repo;
            const branchRef = context.ref;
            // Changed branch extraction for release/* instead of releases/*
            const version = branchRef.replace('refs/heads/release/', '');
            // Changed release link to point to the release/ branch
            const releaseLink = `https://github.com/${owner}/${repo}/tree/release/${version}`;
            const targetUser = "github-actions[bot]"; // Have to replace with the actual username (Github).

            let latestRelease;
            let previousRelease;
            let previousReleaseDate;

            try {
              // Attempt to fetch all releases (including drafts and pre-releases)
              const releasesResponse = await github.rest.repos.listReleases({
                owner,
                repo,
                per_page: 100,
              });
              
              if (releasesResponse.data.length >= 2) {
                // Sort releases descending by creation date (most recent first)
                const releases = releasesResponse.data.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                latestRelease = releases[0];
                previousRelease = releases[1];
                previousReleaseDate = new Date(previousRelease.created_at);
                console.log("Latest release version:", latestRelease.tag_name);
                console.log("Latest release created at:", latestRelease.created_at);
                console.log("Previous release version:", previousRelease.tag_name);
                console.log("Previous release created at:", previousRelease.created_at);
              } else if (releasesResponse.data.length === 1) {
                latestRelease = releasesResponse.data[0];
                // Only one release available; fallback previousReleaseDate to epoch
                previousReleaseDate = new Date(0);
                console.log("Only one release found. Latest release version:", latestRelease.tag_name);
              } else {
                throw new Error("No releases found");
              }
            } catch (error) {
              console.log("Error fetching releases; attempting fallback to tags. Error details:", error);

              // Fallback: Use tags if no releases exist.
              try {
                const tagsResponse = await github.rest.repos.listTags({
                  owner,
                  repo,
                  per_page: 100,
                });
                if (tagsResponse.data.length >= 2) {
                  // Assume tags are returned in descending order (most recent first)
                  const tags = tagsResponse.data;
                  latestRelease = { tag_name: tags[0].name };
                  
                  // Get the commit details for the previous tag to determine its date.
                  const previousTag = tags[1];
                  const commitResponse = await github.rest.repos.getCommit({
                    owner,
                    repo,
                    ref: previousTag.commit.sha,
                  });
                  previousReleaseDate = new Date(commitResponse.data.commit.author.date);
                  
                  console.log("Fallback to tags: Latest tag:", tags[0].name);
                  console.log("Fallback to tags: Previous tag commit date:", previousReleaseDate);
                } else if (tagsResponse.data.length === 1) {
                  latestRelease = { tag_name: tagsResponse.data[0].name };
                  previousReleaseDate = new Date(0);
                  console.log("Fallback to tags: Only one tag found. Latest tag:", tagsResponse.data[0].name);
                } else {
                  throw new Error("No tags found");
                }
              } catch (tagError) {
                console.log("Error fetching tags; defaulting previous release date to epoch start. Error details:", tagError);
                previousReleaseDate = new Date(0);
              }
            }


            
            const searchQuery = `repo:${owner}/${repo} is:issue "The corresponding work item has been closed. The fix should be available in the next release." in:comments`;
            console.log("Search query:", searchQuery);

            const issues = await github.paginate(github.rest.search.issuesAndPullRequests, {
              q: searchQuery,
              per_page: 100,
            });
            console.log(`Found ${issues.length} issues with matching comment.`);

            for (const issue of issues) {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issue.number,
                per_page: 100,
              });
                
              let eligible = false;
              for (const comment of comments) {
                console.log(`Evaluating comment ${comment.id} on issue #${issue.number}`);
                const containsText = comment.body.includes("The corresponding work item has been closed. The fix should be available in the next release.");
                const isFromTargetUser = comment.user.login === targetUser;

                const createdAfter = new Date(comment.created_at) > previousReleaseDate;
                console.log(`Comment ${comment.id}: Contains required text? ${containsText}, Is from target user? ${isFromTargetUser}, Created after last release? ${createdAfter}`);
                  
                if (containsText && isFromTargetUser && createdAfter) {
                  eligible = true;
                  break;
                }
              }
                
              if (eligible) {
                const commentBody = `The fix for this issue is included in version ${version}, which has now been released ([click here](${releaseLink})). This issue will auto close within the next 30 days.`;
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issue.number,
                  body: commentBody,
                });
                console.log(`Comment added to issue #${issue.number}`);
              } else {
                console.log(`Issue #${issue.number} is not eligible; skipping.`);
              }
            }






# name: Comment on Fixed Issues

# on:
#   create:
#     # Trigger when a branch matching releases/* is created. See in forked repo its release/* and not releases/*
#     branches:
#       - 'releases/*'

# jobs:
#   comment-on-issues:
#     runs-on: ubuntu-latest
#     steps:
#       - name: Process issues for new release
#         uses: actions/github-script@v6
#         with:
#           script: |
#             const { owner, repo } = context.repo;
#             const branchRef = context.ref;
#             const version = branchRef.replace('refs/heads/releases/', '');
#             const releaseLink = `https://github.com/${owner}/${repo}/tree/releases/${version}`;
#             const targetUser = "github-actions";

#             let latestRelease;
#             let previousReleaseDate;
#             try {
#               latestRelease = await github.rest.repos.getLatestRelease({ owner, repo });
#               previousReleaseDate = new Date(latestRelease.data.published_at);
#               console.log("Latest release published at:", previousReleaseDate);
#             }catch (error) {
#               console.log("No previous release found; defaulting to epoch start.");
#               previousReleaseDate = new Date(0); // Fallback if no release exists.
#             }
            
#             const searchQuery = `repo:${owner}/${repo} is:issue "The corresponding work item has been closed. The fix should be available in the next release." in:comments`;
#             console.log("Search query:", searchQuery);

#             const issues = await github.paginate(github.rest.search.issuesAndPullRequests, {
#               q: `repo:${owner}/${repo} is:issue "The corresponding work item has been closed. The fix should be available in the next release." in:comments`,
#               per_page: 100,
#             });
#             console.log(`Found ${issues.length} issues with matching comment.`);

#             for (const issue of issues) {
#               const comments = await github.paginate(github.rest.issues.listComments, {
#               owner,
#               repo,
#               issue_number: issue.number,
#               per_page: 100,
#               });
                
#               let eligible = false;
#               for (const comment of comments) {
#                 console.log(`Evaluating comment ${comment.id} on issue #${issue.number}`);
#                 const containsText = comment.body.includes("The corresponding work item has been closed. The fix should be available in the next release.");
#                 const isFromTargetUser = comment.user.login === targetUser;

#                 const createdAfter = new Date(comment.created_at) > previousReleaseDate;
#                 console.log(`Comment ${comment.id}: Contains required text? ${containsText}, Is from target user? ${isFromTargetUser}, Created after last release? ${createdAfter}`);
                  
#                 if (containsText && isFromTargetUser && createdAfter) {
#                   eligible = true;
#                   break;
#                 }
#               }
                
#               if (eligible) {
#                 const commentBody = `The fix for this issue is included in version ${version}, which has now been released ([click here](${releaseLink})). This issue will auto close within the next 30 days.`;
#                 await github.rest.issues.createComment({
#                   owner,
#                   repo,
#                   issue_number: issue.number,
#                   body: commentBody,
#                 });
#                 console.log(`Comment added to issue #${issue.number}`);
#               } else {
#                 console.log(`Issue #${issue.number} is not eligible; skipping.`);
#               }
#             }